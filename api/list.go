package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"net"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type ServerDetailsStruct struct {
	Players `json:"players"`
	ServerQueue
}

type ServerQueue struct {
	CurrentPlayers int64 `json:"currentPlayers"`
	CurrentQueue   int64 `json:"currentQueue"`
}

type Players []Player

//Player details
type Player struct {
	ID          int64    `json:"id"`
	Identifiers []string `json:"identifiers"`
	Name        string   `json:"name"`
	Ping        int64    `json:"ping"`
}

// Generated by https://quicktype.io

type Nopixeldata []NoPixelPlayer

type NoPixelPlayer struct {
	ID        int    `json:"id"`
	Name      string `json:"name"`
	NoPixelID string `json:"noPixelID"`
	SteamID   string `json:"steamID"`
	Twitch    string `json:"twitch"`
}

type Discord struct {
	Members []Member `json:"members"`
}

type Member struct {
	Username      string `json:"username"`
	Discriminator string `json:"discriminator"`
	ID            string `json:"id"`
}

var (
	jsonGet = &http.Client{Timeout: 10 * time.Second}
	//ServerAddress to connect to
	ServerAddress = "66.70.181.77:30120"
	//ServerDetails struct to holds PlayerList & ServerDetails struct
	ServerDetails = &ServerDetailsStruct{}
	//NoPixelData struct
	NoPixelData Nopixeldata
	//
	DiscordData Discord
)

//GetPlayerList sends HTTP get request to server to get list of players
func getPlayerList() (err error) {
	server := strings.Builder{}
	fmt.Fprintf(&server, "http://%s/players.json", ServerAddress)
	req, err := jsonGet.Get(server.String())
	if err != nil {
		return err
	}
	defer req.Body.Close()
	err = json.NewDecoder(req.Body).Decode(&ServerDetails.Players)
	if err != nil {
		return err
	}
	return
}

//GetServerQueueDetails opens UDP socket to FiveM Server and current players and queue from server details
func getServerQueueDetails() (err error) {
	serverData := make([]byte, 256)
	serverConnection, err := net.Dial("udp", ServerAddress)
	defer serverConnection.Close()
	if err != nil {
		return err
	}
	fmt.Fprintf(serverConnection, "\xFF\xFF\xFF\xFFgetinfo f")
	_, err = bufio.NewReader(serverConnection).Read(serverData)

	if err == nil {
		serverData := bytes.Split(serverData, []byte("\n"))
		serverDetails := bytes.Split(serverData[1], []byte("\\"))
		serverQueue := bytes.FieldsFunc(serverDetails[12], func(c rune) bool { return c == '[' || c == ']' })

		currentPlayerValues, _ := strconv.ParseInt(string(serverDetails[4]), 0, 64)
		currentserverQueueValues, _ := strconv.ParseInt(string(serverQueue[0]), 0, 64)
		ServerDetails.ServerQueue.CurrentPlayers = currentPlayerValues
		if currentserverQueueValues >= 1 {
			ServerDetails.ServerQueue.CurrentQueue = currentserverQueueValues
		}
	} else {
		return err
	}
	return
}

func steam64toSteam(input int64) (steamid string) {
	legacySteamid := ((input - 76561197960265728) / 2)
	steamid = fmt.Sprintf("STEAM_0:%d:%d", (input % 2), legacySteamid)
	return
}

func parsePlayers() (err error) {
	var steamIDs []string
	for i, v := range ServerDetails.Players {
		steamIDs = nil
		for ii, vv := range v.Identifiers {
			if ii == 0 {
				hexID := strings.Replace(vv, "steam:", "0x", -1)
				steamID, _ := strconv.ParseInt(hexID, 0, 64)
				s := strconv.FormatInt(steamID, 10)
				p := getPlayerNoPixelInformation(s)

				steamIDs = append(steamIDs,
					p.Name,
					steam64toSteam(steamID),
					fmt.Sprintf("%d", steamID),
					p.Twitch,
					p.NoPixelID)
			}
			if ii > 1 {
				if strings.HasPrefix(vv, "discord:") {
					discordID := strings.Replace(vv, "discord:", "", 1)

					resp, err := getDiscordID(discordID)
					if err != nil {
						fmt.Printf("ERROR: %s\n", err)
					}
					fmt.Println(resp)
					steamIDs = append(steamIDs, fmt.Sprintf("%s#%s", resp.Username, resp.Discriminator))
				}
			}
		}
		ServerDetails.Players[i].Identifiers = steamIDs
	}
	return
}

func loadPlayersJSON() (err error) {
	jsonFile, err := jsonGet.Get("https://nplist.now.sh/players.json")
	if err != nil {
		return
	}
	err = json.NewDecoder(jsonFile.Body).Decode(&NoPixelData)
	if err != nil {
		return err
	}
	return
}

func getPlayerNoPixelInformation(id string) (p NoPixelPlayer) {
	for i := range NoPixelData {
		if NoPixelData[i].SteamID == id {
			return NoPixelData[i]
		}
	}
	return
}

func loadDiscordData() (err error) {
	discord, err := jsonGet.Get("https://discordapp.com/api/servers/491616686928166912/embed.json")

	if err != nil {
		return
	}
	err = json.NewDecoder(discord.Body).Decode(&DiscordData)
	if err != nil {
		return err
	}
	return
}

func getDiscordID(discordID string) (user Member, err error) {
	for i := range DiscordData.Members {
		if DiscordData.Members[i].ID == discordID {
			return DiscordData.Members[i], nil
		}
	}
	return
}

//List handler for now.sh /api/list route
func List(w http.ResponseWriter, r *http.Request) {
	err := loadPlayersJSON()
	if err != nil {
		fmt.Fprintf(w, "failed to load JSON file %v", err)
		return
	}
	getPlayerList()
	loadDiscordData()
	getServerQueueDetails()
	parsePlayers()
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(ServerDetails)
}
